import platform
from pathlib import Path
from typing import Callable, Iterable

from ..button_frame import FluentButtonFrame

# import winaccent  # type: ignore
from PIL import Image  # type: ignore
import customtkinter as ctk  # type: ignore

/
class Colors:
    class Dark:
        class BackgroundColor:
            hex: str = "#2C2C2C"
            r: int = int(hex[1:3], 16)
            g: int = int(hex[3:5], 16)
            b: int = int(hex[5:7], 16)

    class Light:
        class BackgroundColor:
            hex: str = "#F9F9F9"
            r: int = int(hex[1:3], 16)
            g: int = int(hex[3:5], 16)
            b: int = int(hex[5:7], 16)


class Assets:
    DIRECTORY: Path = Path(__file__).parent / "assets"
    LIGHT_ICON: Path = DIRECTORY / "light_icon.png"
    DARK_ICON: Path = DIRECTORY / "dark_icon.png"


class FluentDropdown(ctk.CTkToplevel):
    root: ctk.CTk
    button: "FluentDropdownButton"
    command: Callable | None
    options: Iterable[str]
    visible: bool = False

    MIN_WIDTH: int = 165
    _GAP: int = 4
    _BUTTON_GAP: int = 4
    _PADX: int = 5
    _PADY: int = 5


    def __init__(self, master: ctk.CTk, button: "FluentDropdownButton", options: Iterable[str], command: Callable | None = None) -> None:
        super().__init__(master, fg_color=(Colors.Light.BackgroundColor.hex, Colors.Dark.BackgroundColor.hex))
        self.withdraw()
        self.overrideredirect(True)
        self.button = button
        self.root = master
        self.options = options
        self.command = command

        self.grid_columnconfigure(0, weight=1)
        button_container = ctk.CTkFrame(self, fg_color="transparent")
        button_container.grid(padx=self._PADX, pady=self._PADY, sticky="nsew")
        button_container.grid_columnconfigure(0, weight=1)

        font = ctk.CTkFont(family="Segoe UI")

        for i, option in enumerate(options):
            button_frame = FluentButtonFrame(button_container, height=28, command=lambda option=option: self._callback(option))
            ctk.CTkLabel(button_frame, text=option, font=font).grid(padx=12, pady=6)
            button_frame.bind_all_children()
            button_frame.grid(column=0, row=i, padx=0, pady=0 if i == 0 else (self._BUTTON_GAP, 0), sticky="ew")

        self.update_idletasks()

        self.after(10, self._apply_rounded_corners)

    def _callback(self, option: str) -> None:
        self.button.text_label.configure(text=option)
        if callable(self.command): self.command(option)
        self.hide()


    def show(self) -> None:
        if self.visible: return
        self._set_geometry()
        self.deiconify()
        self.visible = True
        self.focus_set()
        self.after(10, self._loop)


    def hide(self) -> None:
        if not self.visible: return
        self.withdraw()
        self.visible = False


    def _loop(self) -> None:
        if not self.visible: return
        if not self.button.winfo_exists():
            self.hide()
            self.after(10, self.destroy)
            return
        if self.root.focus_get() != self:
            self.hide()
            return
        self.lift()
        self._set_geometry()
        self.after(10, self._loop)


    def _set_geometry(self) -> None:
        w: int = max(self.MIN_WIDTH, self.winfo_reqwidth())
        h: int = self.winfo_reqheight()
        button_x: int = self.button.winfo_rootx()
        button_y: int = self.button.winfo_rooty()
        button_h: int = self.button.winfo_height()

        x = button_x
        y = button_y + button_h + self._GAP

        self.geometry(f"{w}x{h}+{x}+{y}")


    def _apply_rounded_corners(self) -> None:  # Generated by ChatGPT
        def is_windows_11() -> bool:
            version = platform.version()
            try:
                release = int(platform.release())
                build = int(version.split(".")[2])
            except (IndexError, ValueError):
                return False
            return release == 11 or (build >= 22000 and release < 12)
        if not is_windows_11(): return

        from ctypes import windll, byref, sizeof, c_int
        DWMWA_WINDOW_CORNER_PREFERENCE = 33
        DWMNCRP_ROUND = 2
        hwnd = windll.user32.GetParent(self.winfo_id())
        preference = c_int(DWMNCRP_ROUND)
        windll.dwmapi.DwmSetWindowAttribute(hwnd, DWMWA_WINDOW_CORNER_PREFERENCE, byref(preference), sizeof(preference))


class FluentDropdownButton(FluentButtonFrame):
    text_label: ctk.CTkLabel
    icon_label: ctk.CTkLabel

    _PADY: int = 8
    _ICON_PADX: int = 10
    _LABEL_PADX: int = 12
    _INNGER_GAP: int = 7
    _ICON_SIZE: tuple[int, int] = (16, 16)

    _icon: ctk.CTkImage
    _dropdown: FluentDropdown


    def __init__(self, root, master, options: Iterable[str], active: str, command: Callable | None = None, threaded: bool = False, disabled: bool = False, toplevel: bool = False, min_width: int = 0):
        super().__init__(master, height=32, command=self._show_dropdown, threaded=threaded, disabled=disabled, toplevel=toplevel)
        self._icon = ctk.CTkImage(Image.open(Assets.LIGHT_ICON), Image.open(Assets.DARK_ICON), size=self._ICON_SIZE)
        self._dropdown = FluentDropdown(root, self, options, command)

        font = ctk.CTkFont(family="Segoe UI")
        inner_label_width: int = max([font.measure(option) for option in options])
        inner_label_width = max(inner_label_width, min_width - self._INNGER_GAP - self._ICON_PADX - self._LABEL_PADX - self._ICON_SIZE[0])
        self.text_label = ctk.CTkLabel(self, width=inner_label_width, text=active, image=None, font=font, justify="left", anchor="w")
        self.text_label.grid(column=0, row=0, padx=(self._LABEL_PADX, self._INNGER_GAP), pady=self._PADY)
        self.icon_label = ctk.CTkLabel(self, text="", image=self._icon)
        self.icon_label.grid(column=1, row=0, padx=(0, self._ICON_PADX), pady=self._PADY)

        self.bind_all_children()
    

    def set_width(self, width: int) -> None:
        new_width: int = width - self._INNGER_GAP - self._ICON_PADX - self._LABEL_PADX - self._ICON_SIZE[0]
        self.text_label.configure(width=new_width)


    def _show_dropdown(self) -> None:
        if self.enabled: self._dropdown.show()
